<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Understanding the correctness of the Raft algorithm</title>
    <link rel="stylesheet" href="/blog/assets/foghorn.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css">
</head>
<body>
<div>
    <h3 class="home-button" style="text-align: center;"><a href="/blog/">Home</a></h3>
    <h1 class="title">Understanding the correctness of the Raft algorithm</h1>
    <p>During my daily work, I need to learn about the Raft algorithm. This is the first time that I learn about a distributed algorithm. Distributed algorithms work in a surprisingly elegant way. Each node in the algorithm follows a local set of rules, yet the resulting cluster yields some interesting global property. It’s like the free market economy in the computing world :)</p>

<p>The algorithm I think is relatively advanced. Even though the original author was pushing the understandability of the algorithm, it was still fairly complicated which makes its correctness a bit non-obvious. This article tries to explain its correctness better.</p>

<p>The explanation of correctness I want to go for is more deductive than inductive. The reason is in concurrent distributed system settings, there’re just so many combinations of events that can happen. Inductively showing the correctness of certain cases, though can be illuminating, won’t give you the confidence that the algorithm works in all situations. Only by <em>intuitively</em> understanding this algorithm in a <em>deductive</em> manner, I think we can achieve the desired level of confidence.</p>

<p>I will start with posing the problem, briefly describing the algorithm, then try to explain its correctness as clearly as I can.</p>

<h2 id="the-problem">The problem</h2>

<p>The Raft algorithm is framed in its <a href="https://raft.github.io/raft.pdf">original paper</a> as solving the problem of fault-tolerant replicated state machine. We want the state machine to be replicated because of the fault-tolerance requirement, i.e. if one of the state machines somehow becomes dysfunctional, the entire system can still function as there’s duplication available at its replications. Now the system must be replicating automatically, that is to say, the entire system is behaving as if there is only one state machine from the user’s point of view, and the replication happens behind the scene without users needing to know anything about it.</p>

<p>This problem turns out to be non-trivial. The most important problem I think is, just as the cache coherence problem, to ensure consistency across all replicated state machines, so that two state machines will always execute the same sequence of commands. Consider this, if multiple users try to execute different commands to the state machines, how do state machines automatically resolve the divergence so that the replications are all consistent? The problem is worsened given the presence of the state machine failure and network partition, so we must be extra careful to determine when we can safely regard an operation as successful.</p>

<h2 id="the-algorithm">The algorithm</h2>

<p>I will describe the algorithm in a more conceptual way instead of focusing on all the nuances in the algorithm. From now on call each state machine <em>node</em>, the set of all of replicated state machines <em>cluster</em>, the set of other state machines <em>peers</em>.</p>

<p>When a command is received by a node, it is <strong>not</strong> safe to execute it immediately since it needs to resolve any potential differences with its peers. Therefore naturally, we append the command in a local storage called <em>log</em>, which will be used later to resolve divergence and only when it’s safe we can execute the commands in the log. In order not to lose the commands in the log, the log is in persistent storage so that the commands will survive even after node failure. Since each node has a “log”, the entire cluster becomes a “raft” :)</p>

<p>Each node can be in one of the three states, <em>leader</em>, <em>follower</em>, and <em>candidate</em>. In the ideal case (and the 99% common case), there is only one leader and all of its peers are followers. Commands are only submitted to the leader. It puts the command into its log and starts replicating this command to all of its peers. Once a follower receives the command and puts the command into its log, it sends acknowledgement back to the leader so that the leader knows that the command has been replicated to that follower. Once the leader knows that a majority of the followers receive the command, the leader can then determine that this command will never be overridden in the future, hence we can <em>commit</em> the command by actually executing it.</p>

<p>Now the entire cluster having only one command input point might make it sound straightforward, however, the situation becomes complicated when we consider node failure. When the leader dies, a new leader must emerge automatically for the cluster to be able to continue accepting new commands. In Raft, every leader sends periodic heartbeats to peers and once a follower hasn’t received heartbeats from the leader for a certain amount of time, it will start an <em>election</em> process to try to become the leader. It becomes a candidate and requests votes from its peers to acknowledge its conversion to leader. If it gets the majority of votes from peers, it becomes the new leader, and the cluster can proceed with accepting further commands.</p>

<p>Even though ideally only one leader exists at a time, given network partition multiple leaders can exist at the same time, e.g. the original leader is separated from its peers, and the peers start election and get a new leader. To differentiate different leaders, Raft has the concept of <em>term</em> which is an integer that determines which leader is more recent. Since only leaders accept commands and create a new log entry, each command effectively bears a term that’s the same as the leader that issues it. This term number is stored together with the command into the log entry. In general, we prefer commands issued by later term leaders since they are more likely to be consistent with the future state of the cluster.</p>

<p>These concepts <em>leader</em>, <em>follower</em>, <em>candidate</em>, <em>log</em>, and <em>term</em> are the only elements for Raft to ensure safe replication. It’s easy to see that the motivation behind each concept is very natural and clear. I think this is what makes the Raft algorithm feel particularly elegant.</p>

<h2 id="the-correctness">The correctness</h2>

<p>I will now explain the correctness of Raft while at the same time fill in the details of the algorithm that makes it correct. Following the deductive spirit, I will present this section in a theorem-driven manner, where the theorems are listed as the important properties in the original paper. They won’t be as mathematically rigorous but should suffice the explanation purpose here. However, I will still try to discuss the intuitions at length, so that we don’t follow the arguments too closely and lose touch with the core ideas of the algorithm.</p>

<p>Note that although terms are primarily the attribute of leaders, they can be also thought of as the stage of the entire cluster. That is, once a leader is elected of a higher term, the entire cluster is effectively moving on to the new stage where this new leader of the higher term should be in charge of replicating commands. Therefore, each follower and candidate also has a term, which represents what it thinks the current term in the cluster is. Every message a node sends to its peers contains what the node thinks the current term is. If the receiver found the term in the message is higher than the term it thinks should be, then it means it’s already not catching up with what’s happening in the cluster, i.e. the cluster is moving on to the new term already. Therefore, it should update its knowledge on what it thinks the term is. If a leader or candidate learns that there’s a higher term, then it assumes its knowledge about the cluster is already out of date, so it becomes conservative and transitions to a follower immediately.</p>

<p>Now we look at the election process with a bit more details. When a follower becomes a candidate, it will try to become a new leader of its current term plus one. It will vote for itself and ask its peers for votes. However, the receivers of the vote request will only grant vote if the candidate’s term is equal or higher than its own term (if the candidate’s term is higher, it will also update its own term). To make sure the votes are resilient to node failure, each node will put its term knowledge and the candidate id it has voted for this term (or null) into persistent storage together with its log, so that even if a node restarts it won’t grant vote twice for a single term.</p>

<h3 id="theorem-1-election-safety">Theorem 1: Election safety</h3>

<p>At most one leader can exist at a given term.</p>

<h4 id="proof">Proof:</h4>

<p>Assume two leaders are both elected for the term <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>. Since both leaders are elected from a majority of votes, there must be at least one node whose term is or has become <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> that votes for both leaders. This contradicts with the fact that each node stores term and candidate id it voted for the term to persistent storage, and only grant vote if it hasn’t voted for the term before.</p>

<h4 id="qed">QED</h4>

<p>The election safety property makes it much easier to reason about commands. If two commands are of the same term, then they must be issued by the same leader.</p>

<p>Leaders only append commands to their logs and try to replicate the commands to their peers. When a follower receives a leader’s request, based on the leader’s term it either acknowledges the leader’s authority hence commands from it (if the leader’s term is as high as its own), or rejects the leader’s request. In the former case, the follower’s log may be divergent from the leader’s, at which point the leader will force the follower’s log to be identical with its own, so long as the follower still acknowledges the leader’s term is the highest.</p>

<p>The divergence check is implemented by leaders sending the log index and term right before the new commands. A follower will check if the log entry at this index contains the same term as what the leader sends. If they’re not the same, then the follower rejects the request. The leader will have to try to send earlier and earlier log commands until the follower agrees with the leader. This in theory may result in the leader sending its entire log to the follower from the beginning, thus the forcing will always be successful.</p>

<h3 id="theorem-2-log-matching">Theorem 2: Log Matching</h3>

<p>If two commands in two logs are at the same index <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> and of the same term <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>, then all commands up to index <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> are identical in the two logs.</p>

<h4 id="proof-1">Proof:</h4>

<p>Initially, all logs are matching since they are all empty. Logs can only be changed when either a leader appends to its local log, or a follower accepts the leader’s request to add the leader’s commands to its own log. The former case is not relevant as it only involves one log. In the latter case, we assume that the log matching property is satisfied. For the follower to accept the leader’s request, they must match the term <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> at the index <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> right before the new commands. By the log matching hypothesis, all commands up to index <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> are identical. Now overwriting the logs after index <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> will continue to make the log commands identical to that of the leader’s. Therefore, the log matching property is preserved by induction.</p>

<h4 id="qed-1">QED</h4>

<p>It’s now easier to see the overall log structure across the cluster. New commands coming into the cluster system through leaders. Followers may accept replications of a mix of commands from different leaders (with terms in ascending order). However, once a replication happens successfully, logs from the follower and leader must agree up to the point of the successful replication.</p>

<p>There’re also other interesting properties of the log structure, for example:</p>

<ul>
  <li>
    <p>Index invariance. A command never changes its index across logs, so when a log contains a particular command, it must contain the command at the exact same index.</p>
  </li>
  <li>
    <p>Term monotonicity. The terms in the log are increasing monotonically, which follows from that a leader’s term is always greater or equal to the term of the last log entry, and all logs from the followers are prefix of some leader’s.</p>
  </li>
</ul>

<p>The remaining question is how to determine when a command can be considered as committed, that is we know for sure the command will never be overridden for the nodes that have the command in its log. For the nodes that don’t have the command in its log, they will eventually only get that command at the specific index, not other commands. Imagine outside of the logs at each node, there is a virtual log in the cluster that is never overridden, but only extended with a new command once it is known that the command will be executed in the future by all nodes at that index.</p>

<p>An easy guess is for the command to be replicated to the majority. However even so, if there’s a leader of a higher term that doesn’t have that command, then this leader may still override the command even when it’s already replicated to the majority. Therefore, for a command to be truly committed, all leaders of the higher term must have that command in its log.</p>

<p>Raft introduces another check on when a candidate can be granted votes so that an illegal candidate will not be elected. A candidate sends the index and term of its last command in the log, and the receiver will only grant its vote to it if its last command term is higher than the receiver’s last command term, or when they are equal, if the candidate’s last command index is at least as high, hence being at least as long. In general, a node won’t grant its vote to a candidate if it thinks itself has a more update-to-date version of the command log.</p>

<p>With this check, the leader can determine a command being committed, if the command is replicated to the majority, and the command is of the same term as the leader’s own term (this additional condition will be explained later). Once this condition is met, no leaders of a higher term that doesn’t have this command can be elected.</p>

<h3 id="theorem-3-leader-completeness">Theorem 3: Leader completeness</h3>

<p>When a command is committed, all leaders of a higher term will have the command in its log.</p>

<h4 id="proof-2">Proof:</h4>

<p>Assume a leader of term <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord">1</span></span></span></span> committing a command of term <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord">1</span></span></span></span>, such that a leader of term <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord">2</span></span></span></span> doesn’t have this command, with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mn>2</mn><mo>&gt;</mo><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t2 &gt; t1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">t</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord">1</span></span></span></span> and all leaders between term <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>t</mi><mn>1</mn><mo separator="true">,</mo><mi>t</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(t1, t2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mord">2</span><span class="mclose">)</span></span></span></span> have this command in the log. Since the command of term <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord">1</span></span></span></span> is replicated to the majority, and the leader of term <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord">2</span></span></span></span> receives votes from the majority, at least one node <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> has received the replication of command <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord">1</span></span></span></span>, yet still grant its vote to the leader <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord">2</span></span></span></span>. However, this is impossible. If the vote is granted, then either the leader <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord">2</span></span></span></span> has the last command of the same term as the last command of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> but with a longer log, in which case leader <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord">2</span></span></span></span> should have all the commands that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> has. Or in the other case, the leader <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord">2</span></span></span></span> has the last command of term <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> higher than the last command of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> (at least <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>&gt;</mo><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t &gt; t1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65418em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord">1</span></span></span></span> since <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord">1</span></span></span></span> is already in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>’s log). This command of term <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> must be coming from a leader of a term between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>t</mi><mn>1</mn><mo separator="true">,</mo><mi>t</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(t1, t2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>, but by the assumption, all leaders of this range all have the committed command of term <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord">1</span></span></span></span>. So leader <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord">2</span></span></span></span> should also have the committed command <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord">1</span></span></span></span> by the log matching property, if it already matches command of term <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>&gt;</mo><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t &gt; t1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65418em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord">1</span></span></span></span>. In both cases we get a contradiction, so leader <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord">2</span></span></span></span> must have the committed command <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord">1</span></span></span></span> in its log.</p>

<h4 id="qed-2">QED</h4>

<p>Note that we emphasize the committed command must be committed by the leader of the same term <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord">1</span></span></span></span>. If this is not satisfied, and a leader tries to commit a command of term <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mn>0</mn><mo>&lt;</mo><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t0 &lt; t1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">t</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord">1</span></span></span></span>. Then we cannot guarantee that no leader between term <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>t</mi><mn>0</mn><mo separator="true">,</mo><mi>t</mi><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(t0, t1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> doesn’t have command <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">t0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord">0</span></span></span></span>. The previous argument of leader completeness breaks down (at step 3 of section 5.4.3 in the original paper), as there might be a voter that votes for this leader of a term between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>t</mi><mn>0</mn><mo separator="true">,</mo><mi>t</mi><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(t0, t1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>, before it receives the replication of command <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">t0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord">0</span></span></span></span>, hence no contradiction with the voting check. Refer to section 5.4.2 in the paper for some nice illustration of the problem of committing commands from previous terms.</p>

<h2 id="summary">Summary</h2>

<p>With the leader completeness property proved, the correctness of the Raft algorithm is also proved. To summarize, Raft maintains commands in local command logs, and the replication mechanism between nodes will force the logs to become highly consistent. The election mechanism guarantees a leader will not be elected if it doesn’t respect the commands that are already committed.</p>


</div>
</body>
</html>
